"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* istanbul ignore file */
const path_1 = require("path");
const withOffline = require('next-offline');
/**
 * A Next.js plugin that emits a service worker suitable for prefetching
 * assets from Layer0. This plugin also applies the `withLayer0` plugin.
 *
 * Example usage:
 *
 * ```js
 *  // next.config.js
 *
 *  import { withServiceWorker } from '@layer0/next/sw'
 *
 *  module.exports = withServiceWorker({
 *    webpack(config, options) {
 *      // your custom webpack config here
 *    }
 *  })
 * ```
 */
function withServiceWorker(_nextConfig) {
    const normalizedNextConfig = typeof _nextConfig === 'function' ? _nextConfig : () => _nextConfig || {};
    const plugin = (...args) => {
        const { workboxOpts, ...config } = normalizedNextConfig(...args);
        return withOffline({
            generateInDevMode: true,
            generateSw: false,
            workboxOpts: {
                swSrc: path_1.join(process.cwd(), 'sw', 'service-worker.js'),
                swDest: path_1.join(process.cwd(), '.next', 'static', 'service-worker.js'),
                // The asset names for page chunks contain square brackets, eg [productId].js
                // Next internally injects these chunks encoded, eg %5BproductId%5D.js
                // For precaching to work the cache keys need to match the name of the assets
                // requested, therefore we need to transform the manifest entries with encoding.
                manifestTransforms: [
                    (manifestEntries) => {
                        console.log('> Creating service worker...');
                        const manifest = manifestEntries
                            .filter(entry => !entry.url.includes('next/dist') && !entry.url.includes('autostatic/')) // these paths fail in development resulting in the service worker not being installed
                            .map(entry => {
                            entry.url = encodeURI(entry.url);
                            return entry;
                        });
                        return { manifest, warnings: [] };
                    },
                ],
                ...workboxOpts,
            },
            ...config,
        });
    };
    if (typeof _nextConfig === 'function') {
        return plugin;
    }
    else {
        return plugin();
    }
}
exports.default = withServiceWorker;
