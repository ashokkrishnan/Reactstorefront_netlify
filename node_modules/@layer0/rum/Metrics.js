"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const web_vitals_1 = require("web-vitals");
const constants_1 = require("./constants");
const getCookieValue_1 = __importDefault(require("./getCookieValue"));
const getServerTiming_1 = __importDefault(require("./getServerTiming"));
const isChrome_1 = __importDefault(require("./isChrome"));
const uuid_1 = __importDefault(require("./uuid"));
const lodash_debounce_1 = __importDefault(require("lodash.debounce"));
const getSelectorForElement_1 = __importDefault(require("./getSelectorForElement"));
let rumClientVersion;
try {
    rumClientVersion = require('./package.json').version;
}
catch (e) {
    rumClientVersion = 'development';
}
/**
 * Collects browser performance metrics and sends them to Layer0 RUM.
 *
 * Example:
 *
 * ```js
 *  new Metrics({
 *    token: 'my-layer0-rum-token', // you can omit this is your site is deployed on Layer0
 *  }).collect()
 * ```
 */
class BrowserMetrics {
    constructor(options = {}) {
        this.index = 0;
        this.clientNavigationHasOccurred = false;
        /**
         * Sends all collected metrics to Layer0 RUM.
         */
        this.send = lodash_debounce_1.default(() => {
            const body = this.createPayload();
            if (!this.token) {
                console.warn('[RUM] Not sending rum entry because a token was not provided.');
                return;
            }
            if (!this.token.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/)) {
                console.warn(`[RUM] Not sending rum entry because a token "${this.token}" is not valid.`);
                return;
            }
            if (navigator.sendBeacon) {
                // Use `navigator.sendBeacon()` if available, falling back to `fetch()`.
                navigator.sendBeacon(this.sendTo, body);
            }
            else {
                fetch(this.sendTo, { body, method: 'POST', keepalive: true });
            }
            this.index++;
        }, constants_1.SEND_DELAY);
        this.originalURL = location.href;
        this.options = options;
        this.layer0EnvironmentID = getCookieValue_1.default('layer0_eid') || getCookieValue_1.default('xdn_eid');
        this.token = options.token || this.layer0EnvironmentID;
        this.sendTo = `${this.options.sendTo || constants_1.DEST_URL}/${this.token}`;
        this.pageID = uuid_1.default();
        this.metrics = this.flushMetrics();
        this.splitTestVariant = this.getSplitTestVariant();
        try {
            // @ts-ignore
            this.connectionType = navigator.connection.effectiveType;
        }
        catch (e) {
            console.debug('could not obtain navigator.connection metrics');
        }
        /* istanbul ignore else */
        if (this.layer0EnvironmentID != null || location.hostname === 'localhost') {
            this.downloadRouteManifest();
        }
    }
    downloadRouteManifest() {
        const scriptEl = document.createElement('script');
        scriptEl.setAttribute('defer', 'on');
        if (getCookieValue_1.default('layer0_eid')) {
            scriptEl.setAttribute('src', '/__layer0__/cache-manifest.js');
        }
        else {
            scriptEl.setAttribute('src', '/__xdn__/cache-manifest.js');
        }
        document.head.appendChild(scriptEl);
    }
    collect() {
        if (isChrome_1.default()) {
            // We only collect RUM on Chrome because Google only collects core web vitals using Chrome.
            return Promise.all([
                this.toPromise(web_vitals_1.getTTFB),
                this.toPromise(web_vitals_1.getFCP),
                this.toPromise(web_vitals_1.getLCP, true),
                this.toPromise(web_vitals_1.getFID),
                this.toPromise(web_vitals_1.getCLS, true),
            ]).then(() => { });
        }
        else {
            return Promise.resolve();
        }
    }
    flushMetrics() {
        return { clsel: [] };
    }
    /**
     * Returns a promise that resolves once the specified metric has been collected.
     * @param getMetric
     */
    toPromise(getMetric, ...params) {
        return new Promise(resolve => {
            getMetric((metric) => {
                var _a;
                if (metric.delta === 0) {
                    // metrics like LCP will get reported as a final value on first input. If there is no change from the previous measurement, don't bother reporting
                    return resolve();
                }
                this.metrics[metric.name.toLowerCase()] = metric.value;
                if (!this.clientNavigationHasOccurred) {
                    this.clientNavigationHasOccurred = this.originalURL !== location.href;
                }
                if (metric.name === 'CLS') {
                    // record the CLS delta as incremental layout shift if a client side navigation has occurred
                    if (this.clientNavigationHasOccurred) {
                        this.metrics.ils = metric.delta;
                    }
                    // record the element that shifted
                    if ((_a = metric.entries) === null || _a === void 0 ? void 0 : _a.length) {
                        try {
                            // Depending on the DOM layout, there can be MANY elements that shift during each CLS event.
                            // To save on logging costs we only send the first.
                            // @ts-ignore The typings appear to be wrong here - sources contains the elements causing the CLS
                            const source = metric.entries[metric.entries.length - 1].sources[0];
                            // @ts-ignore this.metrics.clsel is always initialized to an empty array
                            this.metrics.clsel.push(getSelectorForElement_1.default(source.node).join(' > '));
                        }
                        catch (e) {
                            // don't fail to report if generating a descriptor fails for some reason
                            /* istanbul ignore next */
                            console.error(e);
                        }
                    }
                }
                if (this.options.debug) {
                    console.log('[RUM]', metric.name, metric.value, `(pageID: ${this.pageID})`);
                }
                /*
                  Note: we can get the elements that shifted from CLS events by:
        
                  metric.entries[metric.entries.length - 1].sources
                    ?.filter((source: any) => source.node != null)
                    .map((source: any) => source.node.outerHTML)
                    .join(', ')
                */
                this.send();
                resolve();
            }, params);
        });
    }
    /**
     * Creates the data payload reported to Layer0 RUM
     */
    createPayload() {
        var _a;
        const timing = getServerTiming_1.default();
        const layer0Routes = timing['xrj'];
        let pageLabel = this.options.pageLabel || ((_a = this.options.router) === null || _a === void 0 ? void 0 : _a.getPageLabel(this.originalURL));
        if (!pageLabel && layer0Routes) {
            try {
                const routes = JSON.parse(layer0Routes);
                pageLabel = routes.path;
            }
            catch (e) {
                pageLabel = layer0Routes;
            }
        }
        if (!this.splitTestVariant) {
            this.splitTestVariant = this.getSplitTestVariant();
        }
        if (!this.connectionType) {
            try {
                // @ts-ignore
                this.connectionType = navigator.connection.effectiveType;
            }
            catch (e) {
                console.debug('could not obtain navigator.connection metrics');
            }
        }
        const data = Object.assign(Object.assign({}, this.metrics), { i: this.index, u0: this.originalURL, cn: this.clientNavigationHasOccurred ? 1 : 0, ux: location.href, pid: this.pageID, t: this.token, ti: document.title, d: this.splitTestVariant, ua: navigator.userAgent, w: window.screen.width, h: window.screen.height, v: this.getAppVersion(timing), cv: rumClientVersion, ht: this.isCacheHit(timing), l: pageLabel, l0: pageLabel, lx: this.getCurrentPageLabel(), c: this.options.country || timing['country'], ct: this.connectionType });
        this.metrics = this.flushMetrics();
        return JSON.stringify(data);
    }
    getAppVersion(timing) {
        return this.options.appVersion || timing['layer0-deployment-id'] || timing['xdn-deployment-id'];
    }
    getSplitTestVariant() {
        return (this.options.splitTestVariant ||
            getCookieValue_1.default('layer0_destination') ||
            getCookieValue_1.default('xdn_destination'));
    }
    isCacheHit(timing) {
        if (this.options.cacheHit != null) {
            return this.options.cacheHit ? 1 : 0;
        }
        const cache = timing['layer0-cache'] || timing['xdn-cache'];
        if (cache === null || cache === void 0 ? void 0 : cache.includes('HIT'))
            return 1;
        return (cache === null || cache === void 0 ? void 0 : cache.includes('MISS')) ? 0 : null;
    }
    /**
     * Returns the page label for the current page using the router specified in options,
     * or, if no router is specified, matches the current URL path to the correct route
     * using the Layer0 cache manifest.
     * @returns
     */
    getCurrentPageLabel() {
        // @ts-ignore
        const manifest = window.__LAYER0_CACHE_MANIFEST__ || window.__XDN_CACHE_MANIFEST__;
        if (this.options.router) {
            return this.options.router.getPageLabel(location.href);
        }
        else if (manifest) {
            const matchingRoute = manifest.find((entry) => entry.returnsResponse &&
                entry.route &&
                new RegExp(entry.route, 'i').test(location.pathname));
            return matchingRoute === null || matchingRoute === void 0 ? void 0 : matchingRoute.criteriaPath;
        }
    }
}
/**
 * Here we stub out Metrics so it doesn't throw an error if accidentally
 * run on the server as might happen with Nuxt, Next, etc...
 */
class ServerMetrics {
    constructor(options) { }
    collect() {
        return Promise.resolve();
    }
}
let MetricsType = ServerMetrics;
if (typeof window !== 'undefined') {
    MetricsType = BrowserMetrics;
}
exports.default = MetricsType;
