"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = withDataBinding;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _react = _interopRequireWildcard(require("react"));

var _DataBindingContext = _interopRequireDefault(require("./DataBindingContext"));

var _amp = require("next/amp");

var _isObject = _interopRequireDefault(require("lodash/isObject"));

var _isString = _interopRequireDefault(require("lodash/isString"));

var _isUndefined = _interopRequireDefault(require("lodash/isUndefined"));

var _upperFirst = _interopRequireDefault(require("lodash/upperFirst"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Converts an object to a string suitable for AMP setState
function ampStringify(object) {
  if ((0, _typeof2["default"])(object) !== 'object') return object;
  var keys = Object.keys(object).map(function (key) {
    return "".concat(key, ":").concat(ampStringify(object[key]));
  });
  return "{".concat(keys.join(','), "}");
} // Converts an expression with dot notation to a nested object
// Example:
//    `foo.bar = value` -> { foo: { bar: value } }


function createStateChange(expression, value) {
  if (expression == null) return null;
  var node = {};
  var state = node;
  var keys = expression.split('.'); // Building out the nested object

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    node[key] = i === keys.length - 1 ? value : {};
    node = node[key];
  }

  return state;
}
/**
 * A higher-order function that adds 2-way databinding to a component.
 *
 * This provides the foundation for making components that can read and write state
 * in both React and AMP using a single API.
 *
 * For example, given a SizeField component that allows the user to choose a product size, but doesn't work in AMP:
 *
 * ```js
 * <SizeField value={product.size} onChange={size => updateStore({ product: { size: value })}/>
 * ```
 *
 * Wrapping it in `withDataBinding(SizeField)` would give you the ability to do this instead, which would work in AMP and React:
 *
 * ```js
 * <SizeField bind="product.size"/>
 * ```
 *
 * To generate more complex Amp event handlers, the "on" attribute can be generated for a component
 * that uses withDataBinding by creating handlers for each event:
 *
 * ```
 * <div
 *   {...amp.on(
 *     amp.createHandler('tap',
 *       amp.setState({ prop: 'index', value: 'event.index' }),
 *       `myCarousel.goToSlide(index=event.index)`
 *     ),
 *     amp.createHandler('slideChange',
 *       amp.setState({ prop: 'index', value: 'event.index' }),
 *       `myOtherCarousel.goToSlide(index=event.index)`
 *     )
 *   )}
 * />
 * ```
 *
 * @param {Function} Component
 * @return {Function}
 */


function withDataBinding(Component) {
  var Wrapped = function Wrapped(_ref) {
    var bind = _ref.bind,
        name = _ref.name,
        props = (0, _objectWithoutProperties2["default"])(_ref, ["bind", "name"]);
    var normalizedBind = normalizeBind(bind);

    var _ref2 = (0, _react.useContext)(_DataBindingContext["default"]) || {},
        ampState = _ref2.ampState,
        getValue = _ref2.getValue,
        setValue = _ref2.setValue;

    var boundProps = getBoundProps(normalizedBind, getValue, setValue);
    var createAmpValueExpression = getAmpValue(ampState, normalizedBind);
    var amp = (0, _amp.useAmp)();

    if (!name && typeof bind === 'string') {
      name = bind;
    }

    return _react["default"].createElement(Component, (0, _extends2["default"])({}, props, boundProps, {
      name: name,
      bind: normalizedBind,
      amp: {
        state: ampState,
        getValue: createAmpValueExpression,
        bind: getAmpBind(amp, bind, createAmpValueExpression),
        on: createAmpHandlerAttribute(amp, normalizedBind, ampState),
        setState: createAmpStateChangeDescriptor,
        createHandler: createAmpHandlerDescriptor(normalizedBind, ampState)
      }
    }));
  };

  Wrapped.propTypes = Component.propTypes;
  return Wrapped;
}
/**
 * Creates a function that creates an amp-bind expression for a given field and prop.
 * @param {Boolean} amp True when amp is enabled
 * @param {Object} bind The bind prop
 * @param {Function} createAmpValueExpression A function that generates AMP values expressions for the current state.
 * @return {Object} A props object to spread
 */


function getAmpBind(amp, bind, createAmpValueExpression) {
  if (!amp || !bind) return function () {
    return {};
  };
  return function (_ref3) {
    var attribute = _ref3.attribute,
        prop = _ref3.prop,
        value = _ref3.value;
    return {
      'amp-bind': "".concat(attribute, "->").concat(value !== undefined ? value : createAmpValueExpression(prop))
    };
  };
}
/**
 * Creates the "on" attribute for a component to react to an AMP event. Uses the descriptors created
 * by amp.createHandler() to generate the attribute by appending the expression strings for each
 * event into an expression usable by Amp.
 * @param {Boolean} amp True when amp is enabled
 * @param {Object} bind The normalized bind expression
 * @param {String} ampState The amp state id
 * @return {Function}
 */


function createAmpHandlerAttribute(amp, bind, ampState) {
  if (!amp || Object.keys(bind).length === 0) return function () {
    return {};
  };
  return function () {
    for (var _len = arguments.length, eventHandlerDescriptors = new Array(_len), _key = 0; _key < _len; _key++) {
      eventHandlerDescriptors[_key] = arguments[_key];
    }

    var eventStrings = eventHandlerDescriptors.filter(Boolean).map(function (eventHandler) {
      return "".concat(eventHandler.event, ":").concat(eventHandler.actions.join(','));
    });
    return eventStrings.length ? {
      on: eventStrings.join(';')
    } : {};
  };
}
/**
 *
 * Creates a descriptor to be used by amp.on() to set the "on" attribute for a component to react to
 * an AMP event
 * @param {Object} normalizedBind The normalized bind object
 * @param {String} ampState The amp state id
 * @return {function(*, ...[*]): {event: *, actions: Array}} Returns a function that expects an event
 * and a list of action descriptors; function will be used by amp.on() to create the "on" attribute
 */


function createAmpHandlerDescriptor(normalizedBind, ampState) {
  return function (event) {
    var actionStrings = [];
    var stateChanges = [];

    for (var _len2 = arguments.length, actions = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      actions[_key2 - 1] = arguments[_key2];
    }

    actions.forEach(function (action) {
      if ((0, _isString["default"])(action)) {
        actionStrings.push(action);
      } else if (action.stateChanges) {
        stateChanges.push.apply(stateChanges, (0, _toConsumableArray2["default"])(action.stateChanges));
      }
    });

    if (stateChanges.length) {
      var changes = createStateChanges(stateChanges, normalizedBind);

      if (changes) {
        // Merge changes into a single change object
        var value = changes.reduce(function (memo, obj) {
          return _objectSpread({}, memo, {}, obj);
        }, {}); // If a change exists, convert that change object into a AMP expression

        if (Object.keys(value).length > 0) {
          actionStrings.push("AMP.setState({".concat(ampState, ":").concat(ampStringify(value), "})"));
        }
      }
    }

    if (actionStrings.length) {
      return {
        event: event,
        actions: actionStrings
      };
    }

    return null;
  };
}
/**
 * Creates an array to use for the state changes needed based on the value/prop pairs
 * @param {Object[]} stateChanges Array of prop+values that should be changed in the state
 * @param {Object} bind The normalized bind object
 * @return {string}
 */


function createStateChanges(stateChanges, bind) {
  return stateChanges.map(function (_ref4) {
    var value = _ref4.value,
        _ref4$prop = _ref4.prop,
        prop = _ref4$prop === void 0 ? 'value' : _ref4$prop;
    var expressions = bind[prop];

    if (!expressions) {
      console.warn("could not create AMP event handler for prop ".concat(prop, ". No prop with that name was found."));
      return;
    }

    return createStateChange(expressions[0], value);
  });
}
/**
 * Creates a descriptor used by createAmpHandlerAttribute to update AMP state when an even occurs
 * @param {Object[]} valuePropPairs A list of objects with a "value" prop for a value expression
 * that would set the optional "prop" prop ("prop" defaults to "value")
 * @return {{stateChanges: Array}} An array of descriptors to be used by amp.createHandler
 */


function createAmpStateChangeDescriptor() {
  var stateChanges = [];

  for (var _len3 = arguments.length, valuePropPairs = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    valuePropPairs[_key3] = arguments[_key3];
  }

  valuePropPairs.forEach(function (pair) {
    if ((0, _isUndefined["default"])(pair.value)) {
      console.warn('AMP state change must have a "value" prop for each object passed to amp.setState');
    } else {
      stateChanges.push(pair);
    }
  });
  return {
    stateChanges: stateChanges
  };
}
/**
 * Converts the following forms of bind:
 *
 * bind="someValue"
 *
 * bind={['preferredValue', 'defaultValue']}
 *
 * bind={{
 *   src: 'thumbnail.src',
 *   alt: 'thumbnail.alt'
 * }}
 *
 * to:
 *
 * bind={{
 *   src: ['thumbnail.src'],
 *   alt: ['thumbnail.alt']
 * }}
 *
 * @param {Object|String[]|String} bind The raw bind prop value
 * @return {Object}
 */


function normalizeBind(bind) {
  if (!bind) return {};

  if (!(0, _isObject["default"])(bind) || Array.isArray(bind)) {
    bind = {
      value: bind
    };
  }

  for (var key in bind) {
    bind[key] = normalizeBindValue(bind[key]);
  }

  return bind;
}
/**
 * Ensures that the specified value expression is an array
 * @param {String|String[]} value
 * @return {String[]}
 */


function normalizeBindValue(value) {
  if (Array.isArray(value)) {
    return value;
  } else {
    return [value];
  }
}
/**
 * Creates value and event handler props for each bound property.  In other words,
 * for `bind="value"`, returns:
 *
 * ```js
 * {
 *   value: (the value)
 *   onChange: (function to update the value)
 * }
 * ```
 *
 * @param {Object} bind
 * @param {Function} getValue
 * @param {Function} setValue
 * @return {Object}
 */


function getBoundProps(bind, getValue, setValue) {
  var props = {};

  var _loop = function _loop(prop) {
    var expression = bind[prop];
    props[prop] = getBoundValue(expression, getValue);

    if (expression.length === 1) {
      props[getCallback(prop)] = function (value) {
        setValue(expression[0], value);
      };
    }
  };

  for (var prop in bind) {
    _loop(prop);
  }

  return props;
}
/**
 * Gets the name of the event callback
 * @param {String} prop
 * @return {String}
 */


function getCallback(prop) {
  if (prop === 'value') {
    return 'onChange';
  } else {
    return "on".concat((0, _upperFirst["default"])(prop), "Change");
  }
}
/**
 * Gets the current value in the store for a binding
 * @param {String[]} expressions
 * @param {Function} getValue
 */


function getBoundValue(expressions, getValue) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = expressions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var expression = _step.value;
      var value = getValue(expression);

      if (value != null) {
        return value;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return null;
}
/**
 * Returns an expression to get a value from the AMP state.
 * @param {String} ampState The amp state id
 * @param {Object} bind The bind expressions
 * @return {String}
 */


function getAmpValue(ampState, bind) {
  return function () {
    var prop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'value';

    if (!bind[prop]) {
      return null;
    } else if (bind[prop].length === 1) {
      return "".concat(ampState, ".").concat(bind[prop]);
    } else {
      return "(".concat(bind[prop].map(function (v) {
        return "".concat(ampState, ".").concat(v);
      }).join('||'), ")");
    }
  };
}
//# sourceMappingURL=withDataBinding.js.map