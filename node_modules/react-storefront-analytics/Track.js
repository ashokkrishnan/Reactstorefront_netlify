"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _react = _interopRequireDefault(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _useAnalytics2 = _interopRequireDefault(require("./useAnalytics"));

var _amp = require("next/amp");

var _TrackAmp = _interopRequireDefault(require("./TrackAmp"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Returns the value of the trigger normalized to an object. If trigger is a string,
 * this function will return { [trigger]: event }
 */
var getTriggerEvents = function getTriggerEvents(event) {
  if (typeof event === 'string') {
    return {
      onClick: event
    };
  } else {
    return event;
  }
};
/**
 * Fires an analytics event when the user interacts with the child component.  By default this fires when the user
 * clicks on the child component, but this can be overriden using the `event` prop.  The value of event should
 * be the name of the event prop to bind to. All additional props will be passed as options along with the event.
 *
 * Example:
 *
 * <Track event="addedToCart" product={this.props.product}>
 *  <Button>Add to Cart</Button>
 * </Track>
 *
 * To trigger events on multiple triggers provide the event prop as an object:
 *
 * <Track event={{onClick: 'onProductClicked', onFocus: 'onProductFocus'}} product={this.props.product}>
 *  <Button>Add to Cart</Button>
 * </Track>
 */


var Track = function Track(_ref) {
  var children = _ref.children,
      event = _ref.event,
      onSuccess = _ref.onSuccess,
      data = (0, _objectWithoutProperties2["default"])(_ref, ["children", "event", "onSuccess"]);
  var triggerEvents = getTriggerEvents(event);

  if (event && (0, _amp.useAmp)()) {
    return _react["default"].createElement(_TrackAmp["default"], {
      event: triggerEvents,
      data: data
    }, children);
  }

  var _useAnalytics = (0, _useAnalytics2["default"])(),
      fire = _useAnalytics.fire;

  var fireEvent = function fireEvent(e) {
    setTimeout(
    /*#__PURE__*/
    (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee() {
      var trigger, rest;
      return _regenerator["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              // Next adds a 'trigger' prop
              trigger = data.trigger, rest = (0, _objectWithoutProperties2["default"])(data, ["trigger"]);
              _context.next = 3;
              return fire(e, rest);

            case 3:
              onSuccess();

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })));
  };

  var child = children && _react["default"].Children.only(children);

  if (!child) return null;
  var triggerHandlers = {};

  var _loop = function _loop(trigger) {
    var originalHandler = child.props[trigger];

    triggerHandlers[trigger] = function () {
      if (originalHandler) originalHandler.apply(void 0, arguments);
      fireEvent(triggerEvents[trigger]);
    };
  };

  for (var trigger in triggerEvents) {
    _loop(trigger);
  }

  return _react["default"].cloneElement(child, _objectSpread({}, child.props, {}, triggerHandlers));
};

Track.propTypes = {
  /**
   * The name of the event to emit. When specified as a string then the default trigger
   * is 'onClick'. Can be provided as an object, eg {onClick: 'productClicked', onMouseOver: 'productHovered'}
   * to specify a custom trigger or multiple events.
   */
  event: _propTypes["default"].oneOfType([_propTypes["default"].string, _propTypes["default"].object]),

  /**
   * A function to call once the event has been successfully sent by all analytics targets.
   */
  onSuccess: _propTypes["default"].func
};
Track.defaultProps = {
  trigger: 'onClick',
  onSuccess: Function.prototype
};
var _default = Track;
exports["default"] = _default;
//# sourceMappingURL=Track.js.map